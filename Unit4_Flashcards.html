<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 4 - OOMD Study Guide</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        
        .navbar { background: rgba(255,255,255,0.95); padding: 15px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.3); position: sticky; top: 0; z-index: 1000; }
        
        .navbar-content { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; max-width: 1200px; margin: 0 auto; padding: 0 20px; }
        
        .nav-link { color: #333; text-decoration: none; padding: 10px 20px; border-radius: 5px; background: #f0f0f0; transition: all 0.3s ease; font-weight: 600; }
        
        .nav-link:hover { background: #667eea; color: white; transform: translateY(-2px); }
        
        .nav-link.active { background: #667eea; color: white; }
        
        .container { max-width: 1200px; margin: 30px auto; padding: 0 20px 30px 20px; }
        
        .header { text-align: center; color: white; margin-bottom: 30px; }
        
        .header h1 { font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); margin-bottom: 10px; }
        
        .section { background: white; border-radius: 10px; padding: 25px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .section-title { color: #667eea; font-size: 1.5em; font-weight: bold; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 3px solid #667eea; }
        
        .topic { margin-bottom: 25px; }
        
        .question { color: #d32f2f; font-weight: 600; font-size: 1.1em; margin-bottom: 10px; }
        
        .answer { color: #333; line-height: 1.8; margin-left: 15px; }
        
        .answer ul { list-style: none; padding: 0; }
        
        .answer li { padding: 8px 0; padding-left: 20px; position: relative; }
        
        .answer li::before { content: "‚ñ∏"; color: #667eea; font-weight: bold; position: absolute; left: 0; }
        
        .highlight { background: #fff9c4; padding: 2px 6px; border-radius: 3px; font-weight: 600; }
        
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        
        th, td { border: 2px solid #667eea; padding: 12px; text-align: left; }
        
        th { background: #667eea; color: white; font-weight: 600; }
        
        tr:nth-child(even) { background: #f5f5f5; }
        
        .diagram-box { background: #f9f9f9; padding: 15px; border-radius: 8px; border: 2px solid #667eea; text-align: center; margin: 15px 0; }
        
        .diagram-box img { max-width: 100%; border-radius: 5px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="navbar-content">
            <a href="OOMD_Checker.html" class="nav-link">üè† Home Checker</a>
            <a href="Unit3_Flashcards.html" class="nav-link">üìö Unit 3</a>
            <a href="Unit4_Flashcards.html" class="nav-link active">üìö Unit 4</a>
            <a href="Unit5_Flashcards.html" class="nav-link">üìö Unit 5</a>
            <a href="Unit6_Flashcards.html" class="nav-link">üìö Unit 6</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="header">
            <h1>üìö UNIT 4 STUDY GUIDE</h1>
        </div>

        <div class="section">
            <div class="section-title">Reuse Plan</div>

            <div class="topic">
                <div class="question">Q: Define Reuse Plan. Explain Library, Framework, Pattern</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Reuse Plan:</span> Systematic strategy identifying what components can be reused, from where, and how they'll be adapted during system development</li>
                        <li><strong>Key Objectives:</strong> Reduce development effort, improve software quality, promote standardization, increase productivity</li>
                    </ul>
                    <table>
                        <tr>
                            <th>Type</th>
                            <th>Definition</th>
                            <th>Features</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Library</strong></td>
                            <td>Collection of reusable classes or functions providing specific functionality</td>
                            <td>Called by application, provides ready-made functionality, no control over app flow</td>
                            <td>Math library, Java Collections, Utility libraries</td>
                        </tr>
                        <tr>
                            <td><strong>Framework</strong></td>
                            <td>Reusable application structure defining architecture and flow of control</td>
                            <td>Framework calls user code, provides extensible components, supports large-scale reuse, Inversion of Control</td>
                            <td>Spring, .NET, Django, Hibernate</td>
                        </tr>
                        <tr>
                            <td><strong>Pattern</strong></td>
                            <td>Reusable solution to recurring design problem in specific context</td>
                            <td>Reuses design knowledge (not code), language-independent, improves maintainability, proven solutions</td>
                            <td>Singleton, Factory, Observer, MVC</td>
                        </tr>
                    </table>
                    <ul>
                        <li><strong>Role in Reuse Plan:</strong></li>
                        <li>‚Ä¢ Library ‚Üí Ready-made tools (code reuse)</li>
                        <li>‚Ä¢ Framework ‚Üí Ready-made structure (architecture reuse)</li>
                        <li>‚Ä¢ Pattern ‚Üí Ready-made idea (design reuse)</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Different Reuse Things Considered During System Modeling</div>
                <div class="answer">
                    <ul>
                        <li><strong>1. Reusable Classes:</strong> Classes designed for reuse, general-purpose and loosely coupled</li>
                        <li><strong>2. Reusable Components:</strong> Self-contained modules that can be plugged into different systems</li>
                        <li><strong>3. Libraries:</strong> Provide common services, reduce duplicate coding</li>
                        <li><strong>4. Frameworks:</strong> Provide reusable system architecture, define application structure</li>
                        <li><strong>5. Design Patterns:</strong> Reuse of proven design solutions, improves design consistency</li>
                        <li><strong>6. UML Models:</strong> Reusable class diagrams, reusable interaction diagrams</li>
                        <li><strong>7. Domain Models:</strong> Reuse of domain knowledge, speeds up analysis phase</li>
                        <li><strong>Benefits:</strong> Faster development, reduced errors, improved quality, easier maintenance</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Software Control Strategies & External Control</div>

            <div class="topic">
                <div class="question">Q: Software Control Strategies in System Design</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Software Control Strategy:</span> Defines how execution flow of system is managed - who controls whom, when actions triggered, how components interact</li>
                    </ul>
                    <table>
                        <tr>
                            <th>Strategy</th>
                            <th>Description</th>
                            <th>Characteristics</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Centralized Control</strong></td>
                            <td>Single control object manages entire system execution</td>
                            <td>One main controller, controls sequence, other objects passive, simple, Call-Return/Manager Model</td>
                            <td>Main program with subroutines, ATM controller managing all operations</td>
                        </tr>
                        <tr>
                            <td><strong>Event-Driven Control</strong></td>
                            <td>Flow determined by events from users or system</td>
                            <td>No central controller, objects react to events, highly flexible, suitable for interactive systems</td>
                            <td>GUI applications, Telephone switching, Real-time systems</td>
                        </tr>
                        <tr>
                            <td><strong>Concurrent Control</strong></td>
                            <td>Multiple processes/threads execute simultaneously</td>
                            <td>Parallel execution, synchronization required, improves performance</td>
                            <td>ATM dispensing cash + printing receipt, Operating systems</td>
                        </tr>
                    </table>
                    <ul>
                        <li><strong>Summary:</strong> Centralized ‚Üí One boss controls everything | Event-Driven ‚Üí Actions on events | Concurrent ‚Üí Many things at once</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Categories of External Control</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">External Control:</span> Control mechanisms where execution flow influenced by external entities (users, devices, time events)</li>
                    </ul>
                    <table>
                        <tr>
                            <th>Category</th>
                            <th>Description</th>
                            <th>Characteristics</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Event-Driven</strong></td>
                            <td>System behavior triggered by external events</td>
                            <td>Asynchronous execution, system reacts to events, no fixed order, sources: user input/hardware/network</td>
                            <td>Button click in GUI, Incoming call in telephone</td>
                        </tr>
                        <tr>
                            <td><strong>Time-Driven</strong></td>
                            <td>Actions triggered at specific time intervals</td>
                            <td>Uses clocks/timers, predictable execution, deterministic behavior, common in embedded systems</td>
                            <td>Alarm systems, Periodic sensor data collection</td>
                        </tr>
                        <tr>
                            <td><strong>Interrupt-Driven</strong></td>
                            <td>Execution interrupted to handle urgent external signals</td>
                            <td>High priority events, immediate response, preempts normal execution, essential for safety-critical</td>
                            <td>Hardware interrupts, Emergency shutdown signal</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Subsystems</div>

            <div class="topic">
                <div class="question">Q: What is Subsystem? How to Organize System into Subsystems?</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Subsystem:</span> Group of related classes/components/objects working together to perform well-defined function within larger system</li>
                        <li><strong>Key Points:</strong> Acts as logical partition, has well-defined interface, hides internal details (information hiding), can be developed/tested independently</li>
                        <li><strong>Steps to Organize:</strong></li>
                        <li>1. <strong>Identify Major Functional Areas:</strong> Analyze requirements, group related functionalities (e.g., ATM ‚Üí Authentication, Transaction, Cash Handling)</li>
                        <li>2. <strong>Define Responsibilities:</strong> Each subsystem has clear responsibility, avoid overlapping</li>
                        <li>3. <strong>Apply High Cohesion:</strong> Classes inside subsystem strongly related</li>
                        <li>4. <strong>Minimize Coupling:</strong> Subsystems depend on each other minimally</li>
                        <li>5. <strong>Define Interfaces:</strong> Interaction only through interfaces</li>
                        <li>6. <strong>Layered Organization:</strong> Presentation ‚Üí Business Logic ‚Üí Data Access</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Ways Subsystems Can Communicate</div>
                <div class="answer">
                    <table>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Direct Method Calls</strong></td>
                            <td>One subsystem directly invokes methods of another</td>
                            <td>Authentication subsystem calling User Database</td>
                        </tr>
                        <tr>
                            <td><strong>Message Passing</strong></td>
                            <td>Subsystems communicate by sending messages or events</td>
                            <td>Event-driven systems</td>
                        </tr>
                        <tr>
                            <td><strong>Shared Data Repository</strong></td>
                            <td>Subsystems communicate via shared database or data store</td>
                            <td>Multiple subsystems accessing same database</td>
                        </tr>
                        <tr>
                            <td><strong>Interface-Based Communication</strong></td>
                            <td>Subsystems interact only through defined interfaces, not direct access</td>
                            <td>Service APIs</td>
                        </tr>
                        <tr>
                            <td><strong>Client-Server Communication</strong></td>
                            <td>One subsystem acts as client, another as server</td>
                            <td>Web application architecture</td>
                        </tr>
                    </table>
                    <ul>
                        <li><strong>Advantages:</strong> Loose coupling, high maintainability, easy scalability, improved reliability</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Breaking System into Subsystems and Allocation</div>
                <div class="answer">
                    <ul>
                        <li><strong>Breaking System into Subsystems:</strong></li>
                        <li>Step 1: Requirement Analysis ‚Üí Study functional and non-functional requirements</li>
                        <li>Step 2: Identify Logical Groups ‚Üí Group related classes and operations</li>
                        <li>Step 3: Define Boundaries ‚Üí Decide what belongs inside each subsystem</li>
                        <li>Step 4: Assign Responsibilities ‚Üí Each subsystem performs single major function</li>
                        <li><strong>Allocation (Assigning subsystems to):</strong></li>
                        <li>1. <strong>Hardware Allocation:</strong> Subsystem mapped to specific hardware (e.g., Sensor subsystem ‚Üí embedded controller)</li>
                        <li>2. <strong>Software Allocation:</strong> Subsystems mapped to software layers (e.g., UI subsystem ‚Üí Presentation layer)</li>
                        <li>3. <strong>Process Allocation:</strong> Subsystems assigned to separate processes or threads</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Data Storage Management</div>

            <div class="topic">
                <div class="question">Q: Data Storage Management in System Design</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Data Storage Management:</span> Deals with how data is stored, accessed, updated, and maintained throughout system lifecycle</li>
                        <li><strong>Defines:</strong> What data to store, where it is stored, how it is accessed, how long it is retained</li>
                        <li><strong>Steps to Design:</strong></li>
                        <li>1. <strong>Identify Data Requirements:</strong> Analyze requirements, identify entities/attributes/relationships (e.g., Customer, Order, Payment)</li>
                        <li>2. <strong>Class Identification & Mapping:</strong> Identify persistent classes, decide which attributes need storage</li>
                        <li>3. <strong>Choose Storage Type:</strong> File-based storage, Database (Relational/Object-oriented)</li>
                        <li>4. <strong>Design Data Structures:</strong> Tables (rows, columns), Objects (attributes, methods), Relationships (associations)</li>
                        <li>5. <strong>Define Access Mechanism:</strong> CRUD operations (Create, Read, Update, Delete), query mechanisms</li>
                        <li>6. <strong>Apply Data Integrity Rules:</strong> Primary keys, foreign keys, constraints</li>
                        <li>7. <strong>Consider Performance & Scalability:</strong> Indexing, caching, data partitioning</li>
                        <li>8. <strong>Security & Backup:</strong> Authentication/authorization, encryption, backup/recovery strategies</li>
                        <li><strong>Importance:</strong> Ensures data consistency, improves performance, enables recovery, supports long-term maintenance</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Data Storage Management in Software Modeling</div>
                <div class="answer">
                    <ul>
                        <li><strong>Key Aspects:</strong></li>
                        <li>1. <strong>Identification of Persistent Objects:</strong> Objects whose data must survive after program execution (e.g., User, Account, Transaction)</li>
                        <li>2. <strong>Data Modeling:</strong> Entity identification, attribute definition, relationship modeling</li>
                        <li>3. <strong>Object-to-Data Mapping:</strong> Classes ‚Üí tables, Attributes ‚Üí columns, Associations ‚Üí keys</li>
                        <li>4. <strong>Storage Abstraction:</strong> Use of Data Access Layer, separation of business logic and data logic</li>
                        <li>5. <strong>Transaction Management:</strong> Ensures ACID (Atomicity, Consistency, Isolation, Durability)</li>
                        <li>6. <strong>Data Access Design:</strong> Use of repositories, encapsulation of storage logic</li>
                        <li>7. <strong>Data Validation & Constraints:</strong> Range checks, uniqueness constraints, referential integrity</li>
                        <li><strong>Benefits:</strong> Cleaner architecture, easier maintenance, reduced redundancy, improved reliability</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Global Resource Handling</div>

            <div class="topic">
                <div class="question">Q: How Global Resources are Handled in System Design</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Global Resource:</span> System-wide resource accessed by multiple objects/components/subsystems simultaneously</li>
                        <li><strong>Examples:</strong> Database connections, files, printers, network sockets, shared memory, global configuration data</li>
                        <li><strong>Need:</strong> Prevent data inconsistency, avoid resource conflicts, ensure safe concurrent access, improve system performance</li>
                        <li><strong>Handling Methods:</strong></li>
                        <li>1. <strong>Centralized Resource Management:</strong> Single controller/manager object manages global resource, other objects request through manager (e.g., Database Connection Manager, Print Manager)</li>
                        <li>2. <strong>Controlled Access Using Interfaces:</strong> Global resources accessed only through well-defined interfaces, direct access restricted</li>
                        <li>3. <strong>Synchronization & Concurrency Control:</strong> When multiple processes access resource, use synchronization (locks, semaphores, mutex)</li>
                        <li>4. <strong>Resource Allocation & Deallocation:</strong> Resources allocated when needed, released after use (prevents wastage and deadlocks)</li>
                        <li>5. <strong>Avoiding Global Variables:</strong> Excessive use increases coupling; use encapsulation and access methods instead</li>
                        <li>6. <strong>Use of Design Patterns:</strong> Singleton (single instance), Object Pool (reuse limited resources), Facade (simplified access)</li>
                        <li>7. <strong>Error Handling & Recovery:</strong> System handles resource failure gracefully (rollback, retry, fallback)</li>
                        <li><strong>Advantages:</strong> Prevents deadlocks, improves stability, ensures consistent data, enhances scalability</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Architecture Styles</div>

            <div class="topic">
                <div class="question">Q: What is Architectural Style?</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Architectural Style:</span> Reusable pattern defining overall structure of software system - specifies how components are organized and interact</li>
                        <li><strong>Defines:</strong> Components of system, their responsibilities, rules for interaction and communication</li>
                        <li><strong>Key Characteristics:</strong> High-level system organization, defines system structure, influences performance and maintainability</li>
                        <li><strong>Importance:</strong> Helps manage complexity, provides design guidance, encourages reuse, improves team communication</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Different Architectural Styles</div>
                <div class="answer">
                    <table>
                        <tr>
                            <th>Style</th>
                            <th>Description</th>
                            <th>Advantages</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Layered Architecture</strong></td>
                            <td>System divided into hierarchical layers (Presentation ‚Üí Business Logic ‚Üí Data Access)</td>
                            <td>Modularity, easy maintenance, clear separation of concerns</td>
                            <td>ATM system, Enterprise applications, Operating systems</td>
                        </tr>
                        <tr>
                            <td><strong>Client-Server</strong></td>
                            <td>Clients request services from centralized server</td>
                            <td>Centralized data management, easy scalability, centralized control</td>
                            <td>Web applications, Banking systems, Internet banking</td>
                        </tr>
                        <tr>
                            <td><strong>Repository</strong></td>
                            <td>All data stored in central repository accessed by components</td>
                            <td>Data consistency, easy backup, simplified data management</td>
                            <td>Database-driven systems, Database systems</td>
                        </tr>
                        <tr>
                            <td><strong>Pipe and Filter</strong></td>
                            <td>Data flows through sequence of processing units (filters)</td>
                            <td>High reusability, easy debugging, step-by-step processing</td>
                            <td>Compiler design, UNIX pipelines</td>
                        </tr>
                        <tr>
                            <td><strong>Model-View-Controller (MVC)</strong></td>
                            <td>Separates data (Model), UI (View), and control logic (Controller)</td>
                            <td>Clear separation, easy maintenance, supports parallel development</td>
                            <td>Web frameworks, Interactive applications</td>
                        </tr>
                        <tr>
                            <td><strong>Event-Driven</strong></td>
                            <td>System flow determined by events rather than predefined sequence</td>
                            <td>Flexible, scalable, suitable for real-time systems</td>
                            <td>GUI applications, Telephone switching, Embedded systems</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Deployment Diagram</div>

            <div class="diagram-box">
                <img src="Deployment_Diagram.jpg" alt="Deployment Diagram">
            </div>

            <div class="topic">
                <div class="question">Q: Explain Node, Association, Dependency in Deployment Diagram</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Deployment Diagram:</span> Represents physical architecture of system - shows how software components deployed on hardware nodes and how nodes communicate</li>
                        <li><strong>Provides runtime view of system</strong></li>
                    </ul>
                    <table>
                        <tr>
                            <th>Element</th>
                            <th>Definition</th>
                            <th>Representation</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Node</strong></td>
                            <td>Physical or logical computational resource that can host software components</td>
                            <td>3D box (Hardware: ATM Machine, Server; Software: JVM, Application Server)</td>
                            <td>ATM Machine, Bank Server, Database Server</td>
                        </tr>
                        <tr>
                            <td><strong>Association</strong></td>
                            <td>Communication link between two nodes showing data exchange and network connectivity</td>
                            <td>Solid line between nodes (labeled with protocol: TCP/IP, HTTP)</td>
                            <td>ATM Machine ‚Üî Bank Server</td>
                        </tr>
                        <tr>
                            <td><strong>Dependency</strong></td>
                            <td>One node depends on another node for services or resources</td>
                            <td>Dashed arrow (points from dependent to provider)</td>
                            <td>ATM Machine ‚Üí Database Server</td>
                        </tr>
                    </table>
                    <ul>
                        <li><strong>Importance:</strong> Shows physical system architecture, helps in performance planning, useful for hardware-software mapping, supports scalability planning</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Transformations</div>

            <div class="topic">
                <div class="question">Q: Batch Transformation vs Continuous Transformation</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Transformation:</span> Way input data is processed to produce output data</li>
                    </ul>
                    <table>
                        <tr>
                            <th>Aspect</th>
                            <th>Batch Transformation</th>
                            <th>Continuous Transformation</th>
                        </tr>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Processes data in groups (batches) rather than immediately</td>
                            <td>Processes data continuously as it arrives</td>
                        </tr>
                        <tr>
                            <td><strong>Processing Mode</strong></td>
                            <td>Group-wise</td>
                            <td>Input-by-input</td>
                        </tr>
                        <tr>
                            <td><strong>Working</strong></td>
                            <td>Data accumulated ‚Üí batch triggered ‚Üí output after completion</td>
                            <td>Input arrives ‚Üí processing instant ‚Üí output immediate</td>
                        </tr>
                        <tr>
                            <td><strong>Response Time</strong></td>
                            <td>Delayed (high latency)</td>
                            <td>Immediate (low latency)</td>
                        </tr>
                        <tr>
                            <td><strong>Real-Time Use</strong></td>
                            <td>No (not suitable)</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Characteristics</strong></td>
                            <td>Collected over time, scheduled intervals, no immediate response, large volumes</td>
                            <td>Real-time processing, no accumulation, immediate response, event-driven</td>
                        </tr>
                        <tr>
                            <td><strong>Advantages</strong></td>
                            <td>Efficient for bulk data, reduced overhead, simple control logic</td>
                            <td>Low latency, suitable for real-time, immediate feedback</td>
                        </tr>
                        <tr>
                            <td><strong>Disadvantages</strong></td>
                            <td>High latency, not suitable for real-time</td>
                            <td>Higher resource usage, complex synchronization</td>
                        </tr>
                        <tr>
                            <td><strong>Examples</strong></td>
                            <td>Payroll processing, Monthly billing, End-of-day bank processing</td>
                            <td>ATM cash withdrawal, Telephone switching, Online transactions</td>
                        </tr>
                    </table>
                    <ul>
                        <li><strong>Summary:</strong> Batch ‚Üí collect data first, process later | Continuous ‚Üí process data immediately</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Component Diagram</div>

            <div class="diagram-box">
                <img src="Component_Diagram.jpg" alt="Component Diagram">
            </div>

            <div class="topic">
                <div class="question">Q: Components of Component Diagram</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Component Diagram:</span> UML diagram depicting organization, dependencies, and interfaces of software components - shows how system divided into components and how they interact</li>
                    </ul>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Definition</th>
                            <th>Representation</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Component</strong></td>
                            <td>Modular, replaceable, reusable part encapsulating implementation and exposing interfaces</td>
                            <td>Rectangle with two small tabs on side</td>
                            <td>Authentication Component, Payment Component, Database Component</td>
                        </tr>
                        <tr>
                            <td><strong>Provided Interface</strong></td>
                            <td>Services offered by component</td>
                            <td>Lollipop symbol (‚óã)</td>
                            <td>ATM provides withdrawCash()</td>
                        </tr>
                        <tr>
                            <td><strong>Required Interface</strong></td>
                            <td>Services needed by component</td>
                            <td>Socket symbol (‚äÇ)</td>
                            <td>Bank Server requires validatePIN()</td>
                        </tr>
                        <tr>
                            <td><strong>Port</strong></td>
                            <td>Point of interaction between component and environment</td>
                            <td>Small square on component boundary</td>
                            <td>Groups related interfaces, controls access</td>
                        </tr>
                        <tr>
                            <td><strong>Dependency</strong></td>
                            <td>One component depends on another for functionality</td>
                            <td>Dashed arrow (points from dependent to provider)</td>
                            <td>ATM Component ‚Üí Bank Server Component</td>
                        </tr>
                        <tr>
                            <td><strong>Connector</strong></td>
                            <td>Communication path between components or interfaces</td>
                            <td>Lines connecting components</td>
                            <td>Assembly Connector, Delegation Connector</td>
                        </tr>
                        <tr>
                            <td><strong>Artifact</strong></td>
                            <td>Physical piece of information produced during development</td>
                            <td>Rectangle with artifact icon</td>
                            <td>.jar file, .exe file, .dll file</td>
                        </tr>
                    </table>
                    <ul>
                        <li><strong>Importance:</strong> Shows system modularization, helps in reuse and maintenance, useful for large-scale systems, supports deployment planning</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">System Performance & Application Class Model</div>

            <div class="topic">
                <div class="question">Q: System Performance Estimation</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">System Performance Estimation:</span> Process of predicting how efficiently system will perform under expected workload conditions before actual implementation</li>
                        <li><strong>Assesses:</strong> Speed, responsiveness, scalability, resource utilization</li>
                        <li><strong>Key Performance Factors:</strong> Response time, throughput, CPU utilization, memory usage, network latency</li>
                        <li><strong>Techniques Used:</strong> Analytical models, simulation models, prototyping, load testing estimates</li>
                        <li><strong>Importance:</strong> Identifies bottlenecks early, helps in hardware sizing, improves user experience, reduces cost of redesign</li>
                        <li><strong>Example (ATM):</strong> Time to authenticate user, time to dispense cash, concurrent user handling</li>
                    </ul>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Interactive Interface, Dynamic Simulation, Real-Time System, Transaction Manager</div>
                <div class="answer">
                    <table>
                        <tr>
                            <th>Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>Interactive Interface</strong></td>
                            <td>Allows users to interact with system and receive immediate feedback</td>
                            <td>User-driven, event-based, requires fast response time</td>
                            <td>ATM screen, Web applications, Mobile apps</td>
                        </tr>
                        <tr>
                            <td><strong>Dynamic Simulation</strong></td>
                            <td>Technique of simulating system behavior over time to analyze performance</td>
                            <td>Study system load, predict bottlenecks, analyze concurrency</td>
                            <td>Simulating multiple ATM users at peak time</td>
                        </tr>
                        <tr>
                            <td><strong>Real-Time System</strong></td>
                            <td>System where correctness depends on both result and time</td>
                            <td>Strict timing constraints, event-driven, deterministic (Hard: Airbag; Soft: Online booking)</td>
                            <td>ATM system, Telephone exchange, Embedded systems</td>
                        </tr>
                        <tr>
                            <td><strong>Transaction Manager</strong></td>
                            <td>Controls execution of transactions to ensure data consistency and reliability</td>
                            <td>Start transaction, commit, rollback on failure, handle concurrency</td>
                            <td>Bank transaction processing, Online payment system</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div class="topic">
                <div class="question">Q: Steps to Construct Application Class Model</div>
                <div class="answer">
                    <ul>
                        <li><span class="highlight">Application Class Model:</span> Represents software-specific classes that implement system functionality, derived from use cases and domain model</li>
                        <li><strong>Steps:</strong></li>
                        <li>1. <strong>Identify Use Cases:</strong> Analyze functional requirements, understand system behavior (e.g., Withdraw Cash, Check Balance)</li>
                        <li>2. <strong>Identify Application Classes:</strong> Identify software-oriented classes responsible for control and coordination (e.g., ATMController, TransactionManager)</li>
                        <li>3. <strong>Identify Attributes:</strong> Determine data needed by each class (e.g., Account ‚Üí accountNumber, balance)</li>
                        <li>4. <strong>Identify Operations:</strong> Operations correspond to use case actions (e.g., validatePIN(), debitAmount())</li>
                        <li>5. <strong>Define Relationships:</strong> Association, dependency, aggregation</li>
                        <li>6. <strong>Apply OO Principles:</strong> High cohesion, low coupling, encapsulation</li>
                        <li><strong>Importance:</strong> Bridges analysis and design, guides coding, improves maintainability</li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</body>
</html>
